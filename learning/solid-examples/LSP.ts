// Базовый класс: все птицы умеют летать
class Bird {
    fly(): void {
        console.log('Птица летит');
    }
}

// Наследник: воробей — обычная птица, летает как и положено
class Sparrow extends Bird {
}

// Наследник: пингвин — хотя он птица, летать он не умеет
class Penguin extends Bird {
    fly(): void {
        // Нарушение LSP: метод fly для пингвина выбрасывает ошибку,
        // так как пингвины не умеют летать
        throw new Error('Пингвины не умеют летать!');
    }
}

// Функция, принимающая объект типа Bird и вызывающая метод fly
function makeBirdFly(bird: Bird): void {
    bird.fly();
}

// Использование:
const sparrow = new Sparrow();
const penguin = new Penguin();

makeBirdFly(sparrow); // Работает корректно, вывод: "Птица летит"
makeBirdFly(penguin); // Выбросит ошибку, так как пингвин не может летать

/*Объяснение
Базовый класс Bird предполагает, что любая птица умеет летать, и имеет метод fly().
Класс Sparrow корректно наследует поведение от Bird.
Класс Penguin наследует от Bird, но его реализация метода fly() выбрасывает ошибку, так как пингвины не умеют летать.
Функция makeBirdFly работает с любым объектом типа Bird, ожидая, что метод fly() отработает корректно. Если вместо
обычной птицы передать пингвина, функция столкнется с ошибкой.
Таким образом, если использовать пингвина в коде, который ожидает поведение базового класса Bird, нарушается принцип
подстановки Лисков: наследник (Penguin) не может заменить базовый класс (Bird) без изменения корректности работы
программы.*/